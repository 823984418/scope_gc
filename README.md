# 基于作用域的安全GC设计

## 在 Rust 中引入 GC 所存在的问题

### 销毁问题
用户可以自行实现 `std::ops::Drop` 来为自定义类型制定销毁动作
```rust
struct A<'s>(&'s i32);

impl Drop for A {
    fn drop(&mut self) {
        println!("drop A({})", self.0);
    }
}
```
如果简单的在栈上创建值，编译器会确保 `drop` 在合适的时刻被调用，然而，复杂的内存管理策略却无法保证调用是及时的  
例如，如果使用 `std::rc::Rc` 来管理 `A<'s>`，并且创建了一个循环引用，值将会存活的比 `'s` 还久  
倘若我们错过了 `drop` 的合理调用时刻，在此之后 `'s` 进入悬空状态，被其修饰的内容都是悬空的，调用 `drop` 就可能导致未定义的行为




